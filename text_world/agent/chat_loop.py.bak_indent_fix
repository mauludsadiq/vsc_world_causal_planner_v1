from __future__ import annotations

import json
from dataclasses import dataclass
from typing import Any, Dict, Tuple

from text_world.agent.planner_bridge import step_safe_from_actions
from text_world.agent.action_parser import predict_action9_topk
from text_world.agent.neural_parser import NeuralParser
from text_world.agent.state_renderer import render_state


@dataclass
class DialogueState:
    seed: int
    epsilon: float
    turn: int = 0
    sid: int = 0


def _select_next_sid(
    sid_in: int,
    epsilon: float,
    seed: int,
    utterance: str,
    action_topk: list[int],
) -> Tuple[int, int, float, str, Dict[str, Any]]:
    out = step_safe_from_actions(
        sid_in=int(sid_in),
        epsilon=float(epsilon),
        seed=int(seed),
        action_ids=[int(a) for a in action_topk],
    )
    return int(out.sid_out), int(out.chosen_action), float(out.chosen_risk), str(out.mode), dict(out.rejected)


def chat_loop(seed: int = 0, epsilon: float = 0.12) -> int:
    ds = DialogueState(seed=int(seed), epsilon=float(epsilon), turn=0, sid=0)

    print("CHAT_LOOP_READY")
    print(json.dumps({"seed": ds.seed, "epsilon": ds.epsilon}, indent=2))

    sid_parser = NeuralParser(NeuralParser.default_model_dir(), device="cpu")

    while True:
        try:
            s = input("> ").strip()
        except EOFError:
            break

        if s == "":
            continue

        if s.lower() in ["exit", "quit"]:
            break

        ds.turn += 1

        action_out = predict_action9_topk(s, k=9, seed=ds.seed)
        sid_out, chosen_action, risk_max, mode, rejected = _select_next_sid(
            ds.sid, ds.epsilon, ds.seed, s, action_out.action_ids
        )

        r = render_state(sid_out)

        print("MAIN_REPLY:")
from text_world.agent.state_renderer import render_sid
r = render_sid(sid_out)
print(r.narration)

        print("ACTION_TRACE:")
        print(json.dumps({
            "parser": "action9",
            "mode": action_out.mode,
            "utterance": s,
            "topk_action_ids": action_out.action_ids,
            "topk_scores": action_out.scores,
        }, indent=2))

        sid256_out = sid_parser.predict_sid256_topk(s, k=5, seed=ds.seed)
        print("SID256_TRACE:")
        print(json.dumps({
            "parser": "sid256",
            "utterance": s,
            "topk_sid_ids": sid256_out.sid_ids,
            "topk_scores": sid256_out.scores,
        }, indent=2))

        print("SAFETY_VERDICT:")
        print(json.dumps({
            "mode": mode,
            "epsilon": ds.epsilon,
            "risk_max": risk_max,
            "ok": True,
            "chosen_action": chosen_action,
            "sid_in": ds.sid,
            "sid_out": sid_out,
            "turn": ds.turn,
        }, indent=2))

        print("COUNTERFACTUAL_REJECTED_BRANCH:")
        print(json.dumps(rejected, indent=2))

        ds.sid = int(sid_out)

        if ds.turn >= 2:
            break

    print("CHAT_LOOP_DONE")
    print(f"turn={ds.turn} last_sid={ds.sid} epsilon={ds.epsilon}")
    return 0


def main() -> int:
    import sys
    seed = int(sys.argv[1]) if len(sys.argv) >= 2 else 0
    epsilon = float(sys.argv[2]) if len(sys.argv) >= 3 else 0.12
    return chat_loop(seed=seed, epsilon=epsilon)


if __name__ == "__main__":
    raise SystemExit(main())
